'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDnd = require('react-dnd');

var _emptyImage = require('./utils/emptyImage');

var _emptyImage2 = _interopRequireDefault(_emptyImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SaturationValueDragSource = function (_React$PureComponent) {
  _inherits(SaturationValueDragSource, _React$PureComponent);

  function SaturationValueDragSource() {
    _classCallCheck(this, SaturationValueDragSource);

    return _possibleConstructorReturn(this, (SaturationValueDragSource.__proto__ || Object.getPrototypeOf(SaturationValueDragSource)).apply(this, arguments));
  }

  _createClass(SaturationValueDragSource, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var img = new Image();
      img.onload = function () {
        return _this2.props.connectDragPreview(img);
      };
      img.src = _emptyImage2.default;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          connectDragSource = _props.connectDragSource,
          radius = _props.radius,
          thickness = _props.thickness;

      var dia = 2 * (radius - thickness);

      var style = {
        position: 'absolute',
        width: dia,
        height: dia,
        border: 'none',
        top: thickness, left: thickness,
        borderRadius: '50%',
        cursor: 'normal'
      };

      return connectDragSource(_react2.default.createElement('div', { style: style }));
    }
  }]);

  return SaturationValueDragSource;
}(_react2.default.PureComponent);

var cardSource = {
  beginDrag: function beginDrag(props) {
    var componentId = props.componentId;

    var el = document.getElementById('color-picker-root-' + componentId);
    var bb = el.getBoundingClientRect();

    return {
      boundingBox: bb
    };
  },

  endDrag: function endDrag(props, monitor) {
    var hue = props.hue,
        radius = props.radius,
        thickness = props.thickness;

    var _monitor$getClientOff = monitor.getClientOffset(),
        x = _monitor$getClientOff.x,
        y = _monitor$getClientOff.y;

    var _monitor$getItem = monitor.getItem(),
        boundingBox = _monitor$getItem.boundingBox;

    var left = boundingBox.left,
        top = boundingBox.top;


    var x1 = x - left - radius;
    var y1 = y - top - radius;

    var rx1 = x1 / (radius - thickness);
    var ry1 = y1 / (radius - thickness);

    var ang = 5 * Math.PI / 3 + hue / 180 * Math.PI;
    var cos30 = Math.cos(ang);
    var sin30 = Math.sin(ang);

    var e1 = +cos30 * rx1 - sin30 * ry1;
    var e2 = -sin30 * rx1 - cos30 * ry1;

    var v2 = (e1 + 1) / 1.5;
    var s2 = 0;

    if (v2 < 0) v2 = 0;
    if (v2 > 1) v2 = 1;

    if (v2 === 0) s2 = 0;else {
      var sc = Math.sqrt(3) * v2;
      s2 = (e2 + sc / 2) / sc;
    }

    if (s2 < 0) s2 = 0;
    if (s2 > 1) s2 = 1;

    if (props.onSaturationChange) {
      props.onSaturationChange(s2);
    }

    if (props.onValueChange) {
      props.onValueChange(v2);
    }
  }
};

var collect = function collect(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview(),
    isDragging: monitor.isDragging()
  };
};

exports.default = (0, _reactDnd.DragSource)('saturation-value', cardSource, collect)(SaturationValueDragSource);